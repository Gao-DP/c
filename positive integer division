描述
将正整数n 表示成一系列正整数之和，n=n1+n2+…+nk, 其中n1>=n2>=…>=nk>=1 ，k>=1 。
正整数n 的这种表示称为正整数n 的划分。正整数n 的不同的划分个数称为正整数n 的划分数。

输入
标准的输入包含若干组测试数据。每组测试数据是一个整数N(0 < N <= 50)。
输出
对于每组测试数据，输出N的划分数。
样例输入
5
样例输出
7
提示
5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1
=====================================================================思路===================================================================
对整数n划分相当看做n=0+n,n=1+n-1,n=2+n-2,....,n=n-1+1
相当于对n-1....1进行划分后的所有可能和减去重复的部分
比如对于5来说，可以有5=0+5,5=1+4,...,5=4+1,再对4...1去划分
但是如果这样，对于整数5=1+4会出现5=1+2+2的划分
对于5=2+3会有5=2+1+2的划分这样的重复部分
之所以会产生重复，原因是，5=1+2+2与5=2+1+2只有数的位置不同，而数相同，实践上是同一种划分
所以应该保证这种情况不出现
所以当对5划分时有5个分支
5=0+5,5=1+4,5=2+3，5=3+2，5=1+4，对于第一个分支要求后面划分时可以出现的最大数是min{5,0}
第二个分支是min{1,4},第三个是min{2,3}....这样就保证了排序是按照从小到大的顺序，不会出现因为顺序不同导致划分不同的情况
====================================================================code=====================================================================
#include <iostream>
using namespace std;

int number;
int divide_integer(int n,int max);
int main()
{
    cin>>number;
    cout<<divide_integer(number,number);
    return 0;
}


int divide_integer(int n,int max)
{
    int times=0;
    if(max<=1)
    return 1;
    for (int i=0;i<n;i++)
    {
        if(n-i<=max)
        times+=divide_integer(n-i,(i<n)?i:n);
    }
    return times;
 
}
